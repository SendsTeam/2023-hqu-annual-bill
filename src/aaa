#include<stdio.h>
#include<stdlib.h>
#define max 1000

typedef struct NODE* Node;
struct NODE {
	int x1;    //指数
	float x2;   //系数
	Node next;
};

Node init(int x1, float x2)
{
	Node n = (Node)malloc(sizeof(struct NODE));
	n->x1 = x1;
	n->x2 = x2;
	n->next = NULL;
	return n;
}

Node insert(Node H, Node r)
{
	Node p = H;
	int flag = 0;
	if (!H->next) {   //链表空状态
		H->next = r;
		return H;
	}
	while (p->next) {
		Node q = p->next;
		if (q->x1 > r->x1) {   //若新数据的指数较小，则往后放
			p = p->next;
			continue;
		}
		else if (q->x1 == r->x1) q->x2 = q->x2 + r->x2;   //两数据的指数相同时，其系数相加
		else if (q->x1 < r->x1) {   //新数据的指数大，则插入该节点前面
			r->next = p->next;
			p->next = r;
		}
		flag++;
		break;
	}
	if (!flag) p->next = r;   //遍历完链表，则将新数据插入到最后一个节点
	return H;
}

Node creat(Node H)
{
	int i;
	for (i = 0; i < max; i++) {
		float t1;
		int t2;
		scanf("%f %d", &t1, &t2);
		Node p = init(t2, t1);
		H = insert(H, p);
		char c = getchar();    //字符为空格时才会继续读取数据
		if (c != ' ') break;
	}
	return H;
}

void output(Node H, int index)
{
	int i = 0;
	Node p = H;
	while(1){
		i++;
		p = p->next;
		if (p->x2 == 0) i--;    //系数为0的项不计数
		if (i == index) {
			printf("%.1f %d", p->x2, p->x1);
			break;
		}
	}
}

int main()
{
	Node H = init(0, 0);
	H = creat(H);
	H = creat(H);
	int index;
	scanf("%d", &index);
	output(H, index);
	return 0;
}
